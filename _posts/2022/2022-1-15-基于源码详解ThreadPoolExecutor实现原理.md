---
layout: post
title: "基于源码详解ThreadPoolExecutor实现原理"
author: "iwts li"
date: 2022-1-15 22:32:00
categories: Java
header-style: text
tags:
  - Java
description: "Java ThreadPoolExecutor"
---

# Java ThreadPoolExecutor

线程池，Thread Pool，是一种基于池化思想管理线程的工具，一般是多线程服务器中使用很多，例如MySQL。

线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。

线程池维护多个线程，等待监督管理者分配可并发执行的任务。从而避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。

1. 降低资源消耗：重复利用已创建的线程，降低线程创建和销毁造成的损耗。
2. 提高响应速度：任务到达时，无需等待线程创建即可立即执行。
3. 提高线程的可管理性：无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
4. 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，允许任务延期执行或定期执行。

# ThreadPoolExecutor核心设计

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405282306037.png)

## 线程池顶级接口Executor

顶层接口```Executor```提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供```Runnable```对象，将任务的运行逻辑提交到执行器（Executor）中，由Executor框架完成线程的调配和任务的执行部分。

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405282307460.png)

简单粗暴，执行就完了。

## 线程池扩充服务接口ExecutorService

ExecutorService接口增加了一些能力：

1. 扩充执行任务的能力，例如```submit()```，可以为一个或一批异步任务生成Future。
2. 提供了管控线程池的方法，例如```shutdown()```，停止线程池的运行。
   
   a. 包括状态监控，例如```isShutdown()```。
3. 执行流程方法，例如```invokeAll()```。

## 线程池抽象类AbstractExecutorService

将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。

## ThreadPoolExecutor实现

最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

# ThreadPoolExecutor运行流程

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290012293.png)

线程池在内部构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。

线程池的运行主要分成两部分：

1. 任务管理。
2. 线程管理。

任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：

1. 直接申请线程执行该任务。
2. 缓冲到队列中等待线程执行。
3. 拒绝该任务。

线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

## 线程池生命周期管理

线程池内部使用一个变量```ctl```维护两个值：
1. 运行状态（runState）
2. 线程数量 (workerCount)

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290013753.png)

在具体实现中，就是进行位运算：

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290013235.png)

```COUNT_BITS```如果是32位的话，那么结合下面的一套左移、与、非的位运算，可以总结为：

1. ctl的高3位保存runState，即运行状态。
2. ctl的低29位保存workerCount，即有效线程数量。

除了ctl解析方法，还提供ctl计算方法，即根据runState和workerCount，计算出ctl值。

这样合并的好处是，操作的时候单锁就可以处理了（CAS也非常方便），位运算速度也快。

### 线程池运行状态

| 运行状态 | 运行状态 | desc |
|:---:|:---:|:----|
| running | 运行 | 能接收新任务，能处理队列任务 |
| shutdown | 关闭 | 不接受新任务，能处理队列任务 |
| stop | 停止 | 不接受新任务，不处理队列任务，中断处理任务的线程 |
| tidying | 整理 | 所有任务已结束，workerCount=0 |
| terminated | | ```terminated()```方法执行后进入该状态 |

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290017023.png)

## 线程池工作流程

### 任务提交

就是一个入口方法，但是分为阻塞和非阻塞：

1. submit：返回Future对象，底层仍然是execute，Future操作时可能会阻塞。
2. execute：常规非阻塞方法，提交后正常执行。

submit是异步编程时可能会用到：

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290018912.png)

本质上是利用Future，还是普通的调用execute执行，对外透出Future对象。

## 任务调度

任务调度是线程池的核心，当用户提交了一个任务，接下来这个任务将如何执行都是由任务调度来决定。核心入口方法：```java.util.concurrent.ThreadPoolExecutor#execute```

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290019016.png)

代码也并不难：

![](https://cdn.jsdelivr.net/gh/iwts/blog-imgs-repo/202405290019298.png)

从上到下5个红框：

1. 线程数小于核心池数量，创建一个新线程并用该线程执行任务。
   
   a. 拉起线程成功则返回。
   
   b. 拉起失败则刷新一下ctl值后继续。
2. 线程在运行并且任务成功添加进任务队列中。
   
   a. 添加成功，执行二次校验，再次校验当前线程是否运行。
    1. 如果不运行则从任务队列中移除当前任务。
       
       i. 移除成功则执行拒绝服务。
    2. 如果当前线程不运行，或者任务列表移除失败。
      
       i. 查看当前线程数量，如果为0，则创建一个线程。
   
   b. 如果线程池不运行，或者任务队列添加失败。
    1. 尝试一次创建一个线程并执行任务。
       
       i. 执行失败则执行拒绝服务。

其中```reject()```方法是拒绝策略，具体参考下面，```addWorker()```下面工作线程部分详讲，目前需要知道是创建了一个工作线程，入参有Runable对象则说明创建后就用这个线程来执行该对象的任务方法，没有就说明只是创建线程。

简而言之：

1. 当前线程数量小于核心池数量，创建线程并执行。
2. 当前线程数量大于核心池数量，且任务队列不满，加入任务队列。
3. 如果任务队列已经满了，但是线程池数量小于线程池设定的最大数量，创建一个线程来执行任务。
4. 如果比最大数量都大，只能拒绝服务。

## 任务缓冲模块设计

任务缓冲模块是线程池能够管理任务的核心。

线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。

线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。

阻塞队列缓存任务，工作线程从阻塞队列中获取任务。

### 任务阻塞队列

阻塞队列的实现是生产者消费者问题的一个解决方案，这个问题具体可以参考：